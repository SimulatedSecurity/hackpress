use crate::models::{DetectedPlugin, DetectedTheme, FoundVulnerability, VulnerabilityDatabase};
use semver::{Version, VersionReq};

pub struct VulnerabilityMatcher;

impl VulnerabilityMatcher {
    pub fn match_vulnerabilities(
        vuln_db: &VulnerabilityDatabase,
        plugins: &[DetectedPlugin],
        themes: &[DetectedTheme],
        wp_version: Option<&str>,
    ) -> Vec<FoundVulnerability> {
        let mut found = vec![];

        // Match plugin vulnerabilities
        for plugin in plugins {
            for vuln in &vuln_db.vulnerabilities {
                if vuln.vuln_type == "plugin" && vuln.target == plugin.slug {
                    if Self::version_matches(&plugin.version, &vuln.affected_versions) {
                        found.push(FoundVulnerability {
                            id: vuln.id.clone(),
                            severity: vuln.severity.clone(),
                            description: vuln.description.clone(),
                            affected_component: plugin.slug.clone(),
                            component_version: plugin.version.clone(),
                            affected_versions: vuln.affected_versions.clone(),
                            references: vuln.references.clone(),
                            vuln_type: "plugin".to_string(),
                        });
                    }
                }
            }
        }

        // Match theme vulnerabilities
        for theme in themes {
            for vuln in &vuln_db.vulnerabilities {
                if vuln.vuln_type == "theme" && vuln.target == theme.slug {
                    if Self::version_matches(&theme.version, &vuln.affected_versions) {
                        found.push(FoundVulnerability {
                            id: vuln.id.clone(),
                            severity: vuln.severity.clone(),
                            description: vuln.description.clone(),
                            affected_component: theme.slug.clone(),
                            component_version: theme.version.clone(),
                            affected_versions: vuln.affected_versions.clone(),
                            references: vuln.references.clone(),
                            vuln_type: "theme".to_string(),
                        });
                    }
                }
            }
        }

        // Match WordPress core vulnerabilities
        if let Some(version) = wp_version {
            for vuln in &vuln_db.vulnerabilities {
                if vuln.vuln_type == "core" {
                    if Self::version_matches(version, &vuln.affected_versions) {
                        found.push(FoundVulnerability {
                            id: vuln.id.clone(),
                            severity: vuln.severity.clone(),
                            description: vuln.description.clone(),
                            affected_component: "wordpress-core".to_string(),
                            component_version: version.to_string(),
                            affected_versions: vuln.affected_versions.clone(),
                            references: vuln.references.clone(),
                            vuln_type: "core".to_string(),
                        });
                    }
                }
            }
        }

        // Sort vulnerabilities: First by type (core -> theme -> plugin), then by severity (critical -> minimal)
        found.sort_by(|a, b| {
            // First: sort by type (core=0, theme=1, plugin=2)
            let type_order = |t: &str| match t {
                "core" => 0,
                "theme" => 1,
                "plugin" => 2,
                _ => 3,
            };
            let a_type = type_order(&a.vuln_type);
            let b_type = type_order(&b.vuln_type);
            
            match a_type.cmp(&b_type) {
                std::cmp::Ordering::Equal => {
                    // Second: sort by severity (critical=0, high=1, medium=2, low=3, minimal=4)
                    let severity_order = |s: &str| match s.to_lowercase().as_str() {
                        "critical" => 0,
                        "high" => 1,
                        "medium" => 2,
                        "low" => 3,
                        "minimal" => 4,
                        _ => 5,
                    };
                    severity_order(&a.severity).cmp(&severity_order(&b.severity))
                }
                other => other,
            }
        });

        found
    }

    fn version_matches(version: &str, affected_ranges: &[String]) -> bool {
        // Parse the detected version
        let detected_version = match Self::parse_version(version) {
            Some(v) => v,
            None => return false, // Can't parse version, skip
        };

        // Check each affected version range
        for range in affected_ranges {
            if Self::matches_range(&detected_version, range) {
                return true;
            }
        }

        false
    }

    fn parse_version(version_str: &str) -> Option<Version> {
        // Clean up version string (remove "v" prefix, handle "unknown", etc.)
        let cleaned = version_str.trim().trim_start_matches('v');
        if cleaned == "unknown" || cleaned.is_empty() {
            return None;
        }

        // Try to parse as semver
        Version::parse(cleaned).ok()
    }

    fn matches_range(version: &Version, range: &str) -> bool {
        // Handle common version range formats
        let range = range.trim();

        // Simple comparison operators
        if range.starts_with("<=") {
            if let Ok(max_version) = Version::parse(&range[2..].trim()) {
                return version <= &max_version;
            }
        } else if range.starts_with(">=") {
            if let Ok(min_version) = Version::parse(&range[2..].trim()) {
                return version >= &min_version;
            }
        } else if range.starts_with("<") {
            if let Ok(max_version) = Version::parse(&range[1..].trim()) {
                return version < &max_version;
            }
        } else if range.starts_with(">") {
            if let Ok(min_version) = Version::parse(&range[1..].trim()) {
                return version > &min_version;
            }
        } else if range.starts_with("=") || range.chars().next().map(|c| c.is_ascii_digit()).unwrap_or(false) {
            // Exact version match
            if let Ok(exact_version) = Version::parse(range.trim_start_matches('=').trim()) {
                return version == &exact_version;
            }
        }

        // Try parsing as VersionReq (supports ranges like ">=1.0.0,<2.0.0")
        if let Ok(req) = VersionReq::parse(range) {
            return req.matches(version);
        }

        false
    }
}
